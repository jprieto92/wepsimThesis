\lhead[\thepage]{CAPÍTULO \thechapter. IMPLEMENTACIÓN Y DESPLIEGUE}
\chead[]{}
\rhead[WepSIM: Simulador de procesador elemental con unidad de control microprogramada\leftmark]{\thepage}
\renewcommand{\headrulewidth}{0.5pt}

\lfoot[]{}
\cfoot[]{}
\rfoot[]{}
\renewcommand{\footrulewidth}{0pt}

%% This is an example first chapter.  You should put chapter/appendix that you
%% write into a separate file, and add a line \include{yourfilename} to
%% main.tex, where `yourfilename.tex' is the name of the chapter/appendix file.
%% You can process specific files by typing their names in at the 
%% \files=
%% prompt when you run the file main.tex through LaTeX.
\chapter{Implementación y despliegue}
\label{ch:implementation_and_deployment}
\markboth{}{IMPLEMENTATION}


Este capítulo trata de la implementación y despliegue del software. En cuanto a la implementación del sistema, se explican las partes más complicadas del código en (Sección  \ref{sec:implementation}, \textit{\nameref{sec:implementation}}). Por otro lado, explicamos los pasos necesarios para desplegar el sistema final (Sección \ref{sec:deployment}, \textit{\nameref{sec:deployment}})


\section{Implementación}
\label{sec:implementation}


Como hemos explicado en el capítulo \ref{ch:analysis}, \textit{\nameref{ch:analysis}}, hemos implementado el simulador utilizando el lenguaje de programación JavaScript junto con HTML5, CSS y las bibliotecas/frameworks JQuery, JQueryUI, JQuery Mobile, Knockout y BootStrap. El motor de simulación es el encargado de ejecutar cada uno de los ciclos de reloj del simulador, tomando como entradas tanto el modelo hardware como el modelo software, pero el desarrollador ha debido de diseñar e implementar el algoritmo que posibilita esta ejecución.

Además, hemos trabajado en conseguir una herramienta que sea capaz de generar la memoria de control mediante la definición del juego de instrucciones por parte del usuario, y de generar el código binario asociado al código ensamblador definido por el usuario; el cual depende del juego de instrucciones definido previamente. Para ello, se han diseñado e implementado dos compiladores diferentes, capaces de generar los binarios correspondientes además de las estructuras de datos necesarias para ayudar al motor de simulación a lo largo de la ejecución.

De esta forma, en \ref{alg:firmware_compiler_pseudocode}, podemos observar el pseudocódigo del proceso de generación de la memoria de control, mientras que en \ref{alg:assembly_compiler_pseudocode} podemos ver el proceso de compilación del código ensamblador definido por el usuario en función de la memoria de control previamente generada, detallando el proceso de compilación del segmento de datos en \ref{alg:data_segment_pseudocode} y el proceso de compilación del segmento de texto en \ref{alg:text_segment_pseudocode}. En \ref{alg:core_simulator_pseudocode} podemos ver el pseudocódigo de como se realiza una simulación, realizando la comprobación de segmentos de memoria, tipo de simulación, y ejecución del ciclo o instrucción correspondiente.

\begin{algorithm}[h]
	\caption{Proceso de compilación del juego de instrucciones}
	\label{alg:firmware_compiler_pseudocode}
  	\scriptsize
  	\setstretch{1.35}
	\begin{algorithmic}[1]
		\Function{compile\_firmware}{$context$ }
		\State $token$ = getToken();
		\State $firmware$ = $null$;
		\State $instructions $= $null$;
		\State $registers$ = $null$;
		\State $pseudoinstructions$ = $null$;
		\While {(!is\_registers($token$) and $token$ != $null$)}
			\State $instruction = null$;
			\State $instructions$[$signature$]=readSignature(getNextToken());
			\State $instructions$[$co$]=readCo(getNextToken());
			\If{(getNextToken() == $COP$)}
				\State $instruction$[$cop$]=readCop(getNextToken());
			\EndIf
			\While {(is\_Field(getNextToken())}
				\State $instructions$[$field$].add=readField(getToken());
			\EndWhile
			\While {(is\_microcode(getNextToken())}
				\State $instructions$[$microcode$].add=readCycle(getToken());
			\EndWhile
			\State $firmware$.add($instructions$);
		\EndWhile
		\If{(is\_registers(getToken())}
			\State $registers$ = readRegisters(getToken());
		\EndIf
		\If{(is\_pseudoInstructions(getToken())}
			\State $pseudoinstructions$ = readPseudoinstructions(getToken());
		\EndIf
		\State $firmware$.add($instructions$);
		\State $firmware$.add($registers$);
		\State $firmware$.add($pseudoinstructions$);
		\State Return $firmware$;
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
	\caption{Proceso de compilación de código ensamblador}
	\label{alg:assembly_compiler_pseudocode}
  	\scriptsize
  	\setstretch{1.35}
	\begin{algorithmic}[1]
		\Function{compile\_assembly}{ $context$,$datosCU$}
		\State $dataSegment$ = $null$;
		\State $textSegment$ = $null$;
		\State $mainMemory$ = $null$;
		\If{(!is\_data\_segment(getToken()))}
			\State Return;
		\EndIf
		\State $dataSegment$ = read\_data\_segment($context$[$dSegment$]);
		\If{(!is\_text\_segment(getToken()))}
			\State Return;
		\EndIf
		\State $textSegment$ = read\_text\_segment($context$[$tSegment$]);
		\State $mainMemory$.add($dataSegment$);
		\State $mainMemory$.add($textSegment$,$dataSegment$.$labels$);
		\State Return $mainMemory$;
		\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
	\caption{Proceso de compilación de código ensamblador: segmento de datos}
	\label{alg:data_segment_pseudocode}
  	\scriptsize
  	\setstretch{1.35}
	\begin{algorithmic}[1]
		\Function{read\_data\_segment}{$context$}
			\State $labels$ = $null$;		
			\State $token$ = getToken();
			\While {(!is\_End(getNextToken())}   \Comment{Check Labels}
				\If{(isLabel(getToken()))}
					\State $labels$.add(getLabel(getToken()));
				\EndIf
			\EndWhile
			\State $dataSegment$[$labels$].add(labels);
			\State $token$ = getFirstToken();
			\For{($i$ in $context$[$directives$])}	\Comment{Read Directives}  
				\State $possible\_datatype$ = $i$;
				\If{($possible\_datatype$ == "$.byte$")}
					$dataSegment$[$directives$].add(readByte($i$));
				\EndIf
				\If{($possible\_datatype$ == "$.half$")}
					$dataSegment$[$directives$].add(readHalf($i$));
				\EndIf
				\If{($possible\_datatype$ == "$.word$")}
					$dataSegment$[$directives$].add(readWord($i$));
				\EndIf
				\If{($possible\_datatype$ == "$.space$")}
					$dataSegment$[$directives$].add(readSpace($i$));
				\EndIf
				\If{($possible\_datatype$ == "$.ascii$")}
					$dataSegment$[$directives$].add(readAscii($i$));
				\EndIf
				\If{($possible\_datatype$ == "$.asciiz$")}
					$dataSegment$[$directives$].add($i$));
				\EndIf
				\If{($possible\_datatype$ == "$.align$")}
					$dataSegment$[$directives$].add(readAlign($i$));
				\EndIf
			\EndFor
			 \State Return $dataSegment$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
	\caption{Proceso de compilación de código ensamblador: segmento de texto}
	\label{alg:text_segment_pseudocode}
  	\scriptsize
  	\setstretch{1.35}
	\begin{algorithmic}[1]
		\Function{read\_text\_segment}{$context$,$labels$}
			\For {($i$ in $labels$}    \Comment{Read Labels}
				\State replaceLabel($context$, $i$);	   \Comment{Replace Label in Text Segment}
			\EndFor
			\For{($i$ in $context$[$instructions$])}     \Comment{Read Instructions}
				\State $auxInstruction$ = fillFields($i$);
				\State $auxBinary$ = $null$;
				\If{(!isInstruction($auxInstruction$[$0$]))}     \Comment{Check if instruction exist}
					\State Return;
				\EndIf
				$auxBinary$ = generateBinary($auxInstruction$);
				\If{($auxBinary$ == $null$)}
					\State Return;
				\EndIf
				$textSegment$.add($auxBinary$);
			\EndFor
			 \State Return $textSegment$
		\EndFunction
	\end{algorithmic}
\end{algorithm}


\begin{algorithm}[h]
	\caption{Proceso de simulación}
	\label{alg:core_simulator_pseudocode}
  	\scriptsize
  	\setstretch{1.35}
	\begin{algorithmic}[1]
		\Function{run\_simulation}{ }
		  \If {(!possible\_execute())}
		    \State Return;
		  \EndIf		
		  \State change\_play\_button();
		  \State execute\_simulation\_inchain();
		\EndFunction
		\Function{execute\_simulation\_inchain}{ }
		   \If {(end\_code())}
		    \State Return;
		   \EndIf	
		   \If {(is\_breakpoint())}
		    \State Return;
		   \EndIf	
		   \If{(execute\_mode == microInstruction)}
		         \State{execute\_microInstruction();}
		   \EndIf
		   \If{(execute\_mode == instruction)}
		         \State{execute\_instruction();}
		   \EndIf	
		\EndFunction
		\Function{execute\_microInstruction}{ }
		\If {(!possible\_execute())}
		    \State Return;
		\EndIf
		\State compute\_general\_behaviour(CLOCK); \Comment{Execute Cycle}
		\State update\_UI();		
		\EndFunction
		\Function{execute\_instruction}{ }
		\If {(!possible\_execute())}
		    \State Return;
		\EndIf
		\Do
		\State compute\_general\_behaviour(CLOCK); \Comment{Execute Cycle}
		\doWhile{($reg\_microaddr$!=$0$ and $mem\_control$[$microAddr$]!=$undefined$)} \Comment{Check Next Cycle}
		\State update\_UI(); \Comment{Update User Interface}
		\EndFunction
	\end{algorithmic}
\end{algorithm}
\clearpage

\section{Despliegue}
\label{sec:deployment}

En esta sección se presenta el despliegue de la herramienta. Para ello, indicamos las especificaciones técnicas recomendadas para que el usuario final obtenga la mejor experiencia posible con la herramienta:

\begin{itemize}

\item \textbf{Sistema Operativo}: Ubuntu 16.04.2 LTS (Linux distribution) /Windows 10 / MacOS 10.12.5.

\item \textbf{Procesador}: Intel(R) Core(TM) i3 CPU 6300 @3.8GHz o superior.

\item \textbf{\gls{ram}}: 4 GB o superior.

\item \textbf{Almacenamiento}: 1 GB de espacio libre en el disco duro (recomendado para el navegador web).

\item \textbf{Red}: La conexión a internet no es necesaria para la ejecución de la herramienta, únicamente para el acceso a ella.

\item \textbf{Software}: Los siguientes navegadores web son los recomendados para el uso de la herramienta:

	\begin{itemize}

	\item[1.] Mozilla Firefox 45+.
	
	\item[2.] Google Chrome 50+.
	
	\item[3.] Microsoft Edge 30+.
	
	\item[4.] Safari 10+.

	\end{itemize}

\end{itemize}

\begin{figure}[htbp]
 	\centering
 	\includegraphics[width=10cm]{figures/folder_diagram}
 	\caption{Estructura de ficheros.}
	\label{fig:folder_structure}
\end{figure}

En caso de desear el usuario descargar el código fuente de la herramienta para realizar cualquier modificación en la definición del modelo hardware o cualquier otro módulo, es necesario explicar la estructura de ficheros que componen el simulador y las dependencias que existen entre sí. De esta forma, en \ref{fig:folder_structure} podemos ver los ficheros que componen la herramienta web, los cuales tienen una serie de dependencias indicadas en \ref{fig:files_dependencies}.

\begin{figure}[htbp]
 	\centering
 	\includegraphics[width=15.5cm]{figures/dependencies_diagram}
 	\caption{Dependencias entre ficheros.}
	\label{fig:files_dependencies}
\end{figure}

Los ficheros que componen WepSIM son detallados a continuación:

\begin{itemize}

\item \textbf{index.html: } este fichero se encarga de la vista de la herramienta, generando la interfaz de usuario de la herramienta.

\item \textbf{gpl.txt y lgpl.txt: } estos ficheros contienen la especificación de las licencias del software.

\item \textbf{sim\char`_cfg.js} este fichero contiene las estructuras de datos de la configuración de la herramienta.

\item \textbf{sim\char`_core\char`_ctrl.js:}  este fichero contiene la implementación del motor de simulación de la herramienta.

\item \textbf{sim\char`_core\char`_ui.js: } este fichero contiene la implementación del motor de la interfaz de usuario de la herramienta.

\item \textbf{sim\char`_hw\char`_cpu.js: } este fichero contiene la definición del modelo hardware de la cpu del simulador.

\item \textbf{sim\char`_hw\char`_io.js: } este fichero contiene la definición del modelo hardware del módulo de generación de interrupciones del simulador.

\item \textbf{sim\char`_hw\char`_kbd.js: } este fichero contiene la definición del modelo hardware del módulo del teclado del simulador.

\item \textbf{sim\char`_hw\char`_scr.js: } este fichero contiene la definición del modelo hardware de la memoria principal del simulador.

\item \textbf{sim\char`_hw\char`_mem.js: } este fichero contiene la definición del modelo hardware de la pantalla del simulador.

\item \textbf{sim\char`_lang.js: } este fichero contiene la implementación de las funciones principales del parser de ficheros de la herramienta.

\item \textbf{sim\char`_lang\char`_asm.js: } este fichero contiene la implementación del compilador de código ensamblador de la herramienta.

\item \textbf{sim\char`_lang\char`_firm.js: } este fichero contiene la implementación del compilador de firmware de la herramienta.

\item \textbf{images/cpu.svg: } este fichero contiene la definición de la imagen vectorial de la cpu de la herramienta.

\item \textbf{images/cpu.svg: } este fichero contiene la definición de la imagen vectorial de la unidad de control de la herramienta.

\item \textbf{external folder: } este directorio contiene las bibliotecas y frameworks que necesita el simulador para su correcto funcionamiento, como son JQuery, JQueryUI, JQuery Mobile, Knockout y BootStrap.

\end{itemize}

En \cite{wepsimManualUser} se presenta el manual completo de usuario de la herramienta, que incluye la especificación del modelo hardware implementado y la explicación de uso del simulador, indicando algunos ejemplos docentes para aprender el uso de esta herramienta.

\afterpage{\blankpage} % blank page