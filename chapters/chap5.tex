\lhead[\thepage]{CAPÍTULO \thechapter. IMPLEMENTACIÓN Y DESPLIEGUE}
\chead[]{}
\rhead[WepSIM: Simulador de procesador elemental con unidad de control microprogramada\leftmark]{\thepage}
\renewcommand{\headrulewidth}{0.5pt}

\lfoot[]{}
\cfoot[]{}
\rfoot[]{}
\renewcommand{\footrulewidth}{0pt}

%% This is an example first chapter.  You should put chapter/appendix that you
%% write into a separate file, and add a line \include{yourfilename} to
%% main.tex, where `yourfilename.tex' is the name of the chapter/appendix file.
%% You can process specific files by typing their names in at the 
%% \files=
%% prompt when you run the file main.tex through LaTeX.
\chapter{Implementación y despliegue}
\label{ch:implementation_and_deployment}
\markboth{}{IMPLEMENTATION}


Este capítulo trata de la implementación y despliegue del software. En cuanto a la implementación del sistema, se explican las partes más complicadas del código en (Sección  \ref{sec:implementation}, \textit{\nameref{sec:implementation}}). Por otro lado, explicamos los pasos necesarios para desplegar el sistema final (Sección \ref{sec:deployment}, \textit{\nameref{sec:deployment}})


\section{Implementación}
\label{sec:implementation}


Como hemos explicado en el capítulo \ref{ch:analysis}, \textit{\nameref{ch:analysis}}, hemos implementado el simulador utilizando el lenguaje de programación JavaScript junto con HTML5, CSS y las bibliotecas/frameworks JQuery, JQueryUI, JQuery Mobile, Knockout y BootStrap. El motor de simulación es el encargado de ejecutar cada uno de los ciclos de reloj del simulador, tomando como entradas tanto el modelo hardware como el modelo software, pero el desarrollador ha debido de diseñar e implementar el algoritmo que posibilita esta ejecución.

Además, hemos trabajado en conseguir una herramienta que sea capaz de generar la memoria de control mediante la definición del juego de instrucciones por parte del usuario, y de generar el código binario asociado al código ensamblador definido por el usuario; el cual depende del juego de instrucciones definido previamente. Para ello, se han diseñado e implementado dos compiladores diferentes, capaces de generar los binarios correspondientes además de las estructuras de datos necesarias para ayudar al motor de simulación a lo largo de la ejecución.

De esta forma, en \ref{alg:core_simulator_pseudocode} podemos ver el pseudocódigo de como en cada ciclo de reloj se realiza la actualización de cada módulo hardware mediante la activación de señales y la propagación de los resultados de cada operación. En \ref{alg:firmware_compiler_pseudocode}, podemos observar el pseudocódigo del proceso de generación de la memoria de control, mientras que en \ref{alg:assembly_compiler_pseudocode} podemos ver el proceso de compilación del código ensamblador definido por el usuario en función de la memoria de control previamente generada.

\vspace{1cm}

\begin{algorithm}[h]
	\caption{Proceso de ejecución de ciclo de reloj}
	\label{alg:core_simulator_pseudocode}
  	\scriptsize
  	\setstretch{1.35}
	\begin{algorithmic}[1]
		\Function{client\_main}{ }
		\While {time < max\_time}
		\State increase $wall\_cpu\_time$ to the running project
		\State \Call{update\_debt}{}
		\State \Call{update\_deadline\_missed}{}
		\State \Call{cpu\_scheduling}{}
		\State \Call{signal}{} Work fetch process
		\State \Call{wait}{} $scheduling\_interval$
		\EndWhile	
		\State Return
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\clearpage

\begin{algorithm}[h]
	\caption{Proceso de compilación del juego de instrucciones}
	\label{alg:firmware_compiler_pseudocode}
  	\scriptsize
  	\setstretch{1.35}
	\begin{algorithmic}[1]
		\Function{work\_fetch}{ }
		\State $project = null$
		\While {time < max\_time}
		\For {each project $p$ in $projects$}
		\If {$p$ meets the requirements}
		\State $project = p$
		\EndIf
		\EndFor
		\If {$project$ and not $deadlines\_missed$}
		\State \Call{ask\_for\_work}{$project$}
		\EndIf		
		\State \Call{wait}{} $work\_fetch\_period$
		\EndWhile	
		\State \Call{signal}{} Client main process
		\State Return
		\EndFunction
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
	\caption{Proceso de compilación de código ensamblador}
	\label{alg:assembly_compiler_pseudocode}
  	\scriptsize
  	\setstretch{1.35}
	\begin{algorithmic}[1]
		\Function{work\_fetch}{ }
		\State $project = null$
		\While {time < max\_time}
		\For {each project $p$ in $projects$}
		\If {$p$ meets the requirements}
		\State $project = p$
		\EndIf
		\EndFor
		\If {$project$ and not $deadlines\_missed$}
		\State \Call{ask\_for\_work}{$project$}
		\EndIf		
		\State \Call{wait}{} $work\_fetch\_period$
		\EndWhile	
		\State \Call{signal}{} Client main process
		\State Return
		\EndFunction
	\end{algorithmic}
\end{algorithm}


\section{Despliegue}
\label{sec:deployment}

En esta sección se presenta el despliegue de la herramienta. Para ello, indicamos las especificaciones técnicas recomendadas para que el usuario final obtenga la mejor experiencia posible con la herramienta:

\begin{itemize}

\item \textbf{Sistema Operativo}: Ubuntu 16.04.2 LTS (Linux distribution) /Windows 10 / MacOS 10.12.5.

\item \textbf{Procesador}: Intel(R) Core(TM) i3 CPU 6300 @3.8GHz or higher.

\item \textbf{\gls{ram}}: 4 GB or higher.

\item \textbf{Almacenamiento}: 1 GB of free space in the Hard Disk Drive (recomendado para el navegador web).

\item \textbf{Red}: La conexión a internet es necesaria para el acceso a la herramienta web.

\item \textbf{Software}: Los siguientes navegadores web son los recomendados para el uso de la herramienta:

	\begin{itemize}

	\item[1.] Mozilla Firefox.
	
	\item[2.] Google Chrome.
	
	\item[3.] Microsoft Edge.
	
	\item[4.] Safari.

	\end{itemize}

\end{itemize}

\begin{figure}[htbp]
 	\centering
 	\includegraphics[width=10cm]{figures/folder_diagram}
 	\caption{Estructura de ficheros.}
	\label{fig:folder_structure}
\end{figure}

En caso de desear el usuario descargar el código fuente de la herramienta para realizar cualquier modificación en la definición del modelo hardware o cualquier otro módulo, es necesario explicar la estructura de ficheros que componen el simulador y las dependencias que existen entre sí. De esta forma, en \ref{fig:folder_structure} podemos ver los ficheros que componen la herramienta web, los cuales tienen una serie de dependencias indicadas en \ref{fig:files_dependencies}.

\begin{figure}[htbp]
 	\centering
 	\includegraphics[width=15.5cm]{figures/dependencies_diagram}
 	\caption{Dependencias entre ficheros.}
	\label{fig:files_dependencies}
\end{figure}

Los ficheros que componen WepSIM son detallados a continuación:

\begin{itemize}

\item \textbf{index.html: } este fichero se encarga de la vista de la herramienta, generando la interfaz de usuario de la herramienta.

\item \textbf{gpl.txt y lgpl.txt: } estos ficheros contienen la especificación de las licencias del software.

\item \textbf{sim\char`_cfg.js} este fichero contiene las estructuras de datos de la configuración de la herramienta.

\item \textbf{sim\char`_core\char`_ctrl.js:}  este fichero contiene la implementación del motor de simulación de la herramienta.

\item \textbf{sim\char`_core\char`_ui.js: } este fichero contiene la implementación del motor de la interfaz de usuario de la herramienta.

\item \textbf{sim\char`_hw\char`_cpu.js: } este fichero contiene la definición del modelo hardware de la cpu del simulador.

\item \textbf{sim\char`_hw\char`_io.js: } este fichero contiene la definición del modelo hardware del módulo de generación de interrupciones del simulador.

\item \textbf{sim\char`_hw\char`_kbd.js: } este fichero contiene la definición del modelo hardware del módulo del teclado del simulador.

\item \textbf{sim\char`_hw\char`_mem.js: } este fichero contiene la definición del modelo hardware de la memoria principal del simulador.

\item \textbf{sim\char`_hw\char`_mem.js: } este fichero contiene la definición del modelo hardware de la pantalla del simulador.

\item \textbf{sim\char`_lang.js: } este fichero contiene la implementación de las funciones principales del parser de ficheros de la herramienta.

\item \textbf{sim\char`_lang\char`_asm.js: } este fichero contiene la implementación del compilador de código ensamblador de la herramienta.

\item \textbf{sim\char`_lang\char`_firm.js: } este fichero contiene la implementación del compilador de firmware de la herramienta.

\item \textbf{images/cpu.svg: } este fichero contiene la definición de la imagen vectorial de la cpu de la herramienta.

\item \textbf{images/cpu.svg: } este fichero contiene la definición de la imagen vectorial de la unidad de control de la herramienta.

\item \textbf{external folder: } este directorio contiene las bibliotecas y frameworks que necesita el simulador para su correcto funcionamiento, como son JQuery, JQueryUI, JQuery Mobile, Knockout y BootStrap.

\end{itemize}

En el apéndice \ref{ch:user_manual} se presenta el manual completo de usuario de la herramienta, que incluye la especificación del modelo hardware implementado y la explicación de uso del simulador, indicando algunos ejemplos docentes para aprender el uso de esta herramienta.

\afterpage{\blankpage} % blank page